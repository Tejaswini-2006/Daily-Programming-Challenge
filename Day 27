/*Day 27 of 30 

Problem : Find the Shortest Path in an Unweighted Graph
You are given an unweighted graph represented by an adjacency list. Your task is to find the shortest path (in terms of the number of edges) between two given nodes in the graph.

Input :
* An integer V representing the number of vertices in the graph.
* A list of edges, where each edge connects two vertices of the graph.
* Two integers, start and end, representing the source and destination nodes respectively.
* V = 5, Edges = [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]], start = 0, end = 4

Output :
Return the shortest path length (number of edges) from start to end. If there is no path, return -1.
Output: 3
*/
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX 10000  // maximum vertices

// Queue implementation for BFS
typedef struct {
    int items[MAX];
    int front, rear;
} Queue;

void initQueue(Queue* q) {
    q->front = q->rear = -1;
}

bool isEmpty(Queue* q) {
    return q->front == -1;
}

void enqueue(Queue* q, int value) {
    if (q->rear == MAX - 1) return; // overflow
    if (q->front == -1) q->front = 0;
    q->items[++q->rear] = value;
}

int dequeue(Queue* q) {
    if (isEmpty(q)) return -1;
    int value = q->items[q->front];
    if (q->front == q->rear)
        q->front = q->rear = -1;
    else
        q->front++;
    return value;
}

// Function to find shortest path using BFS
int shortestPath(int V, int edges[][2], int E, int start, int end) {
    // adjacency list
    int* adj[V];
    int adjSize[V];
    for (int i = 0; i < V; i++) {
        adj[i] = (int*)malloc(V * sizeof(int));
        adjSize[i] = 0;
    }

    // build graph (undirected)
    for (int i = 0; i < E; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u][adjSize[u]++] = v;
        adj[v][adjSize[v]++] = u;
    }

    // BFS
    bool visited[V];
    int dist[V];
    for (int i = 0; i < V; i++) {
        visited[i] = false;
        dist[i] = -1;
    }

    Queue q;
    initQueue(&q);
    visited[start] = true;
    dist[start] = 0;
    enqueue(&q, start);

    while (!isEmpty(&q)) {
        int node = dequeue(&q);

        for (int i = 0; i < adjSize[node]; i++) {
            int neighbor = adj[node][i];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                dist[neighbor] = dist[node] + 1;
                enqueue(&q, neighbor);

                if (neighbor == end) { // found shortest path
                    return dist[neighbor];
                }
            }
        }
    }

    return -1; // no path
}

int main() {
    int V = 5;
    int edges[][2] = {{0, 1}, {0, 2}, {1, 3}, {2, 3}, {3, 4}};
    int E = sizeof(edges) / sizeof(edges[0]);
    int start = 0, end = 4;

    int result = shortestPath(V, edges, E, start, end);
    printf("Shortest Path Length: %d\n", result);

    return 0;
}
output
V = 5
Edges = [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]]
start = 0, end = 4
Shortest Path Length: 3

