/*Day 12 of 30 

Problem : Valid Parentheses with Multiple Types
You are given a string s consisting of different types of parentheses: (), {}, and []. Your task is to determine whether the given string is valid.
A string is considered valid if:
1. Every opening bracket has a corresponding closing bracket of the same type.
2. The brackets are closed in the correct order. This means that a closing bracket must close the most recent unmatched opening bracket.

Input :
A string s consisting of characters (, ), {, }, [, and ].
Input: s = "[{()}]"

Output :
- Return true if the string is valid.
- Return false if the string is invalid.
Output: true
*/

#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define MAX 10000   // Maximum size for input string

// Function to check if two characters are matching brackets
bool isMatching(char open, char close) {
    return (open == '(' && close == ')') ||
           (open == '{' && close == '}') ||
           (open == '[' && close == ']');
}

// Function to check if the string has valid parentheses
bool isValid(char *s) {
    char stack[MAX];
    int top = -1;

    for (int i = 0; s[i] != '\0'; i++) {
        char ch = s[i];

        // If opening bracket, push to stack
        if (ch == '(' || ch == '{' || ch == '[') {
            stack[++top] = ch;
        }
        // If closing bracket, check with top of stack
        else if (ch == ')' || ch == '}' || ch == ']') {
            if (top == -1 || !isMatching(stack[top], ch)) {
                return false;  // Unmatched
            }
            top--; // Pop the matched opening bracket
        }
    }

    // If stack is empty, all brackets matched
    return top == -1;
}

int main() {
    char s[MAX];

    printf("Enter a string with brackets: ");
    scanf("%s", s);

    if (isValid(s))
        printf("true\n");
    else
        printf("false\n");

    return 0;
}
OUTPUT
Input: () 
Output: true

Input: ([)] 
Output: false

Input: [{()}] 
Output: true

Input: "" 
Output: true

Input: {[} 
Output: false

